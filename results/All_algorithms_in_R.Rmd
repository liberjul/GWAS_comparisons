---
title: "GWAS algorithm setup"
output: html_notebook
---

```{r}
# importa=ing data was done from the p.exact library, data.table useful for fast table operations
library(p.exact)
library(data.table)
```
```{r}
#retrieval of data form p.exact's Arabidopsis dataset
data(arab)
pheno <- phdata(arab)
geno <- gtdata(arab)

#Calculate kinship matrix
gkin <- ibs(arab, weight="freq")

```

```{r}

#covert data to dataframes
#WARNING: takes many hours to run
snp_geno_df <- as.genotype.snp.data(geno)
write.csv(pheno, file="Arabidopsis_pheno.csv")
write.csv(snp_geno_df, file="Arabidopsis_geno.txt")
write.csv(gkin, file="Arabidopsis_kin.txt")
```

```{r}
#Set up dataframes for analysis
snp_geno_df <- fread("Arabidopsis_geno.txt", sep=",")
snp_info <- rbind(arab@gtdata@snpnames, arab@gtdata@chromosome)
snp_info <- rbind(snp_info, arab@gtdata@map)
snp_info <- rbind(snp_info, rep("1/1", dim(snp_info)[2]))
hapName <- c("rs#","chrom","pos","genotype for code 1")
snp_info <- cbind(hapName, snp_info)
colnames(snp_info) <- colnames(snp_geno_df)
snp_geno_df <- rbind(snp_info, snp_geno_df[2:199])
t_snp_geno_df <- transpose(snp_geno_df)
rownames(t_snp_geno_df) <- colnames(snp_geno_df)
colnames(t_snp_geno_df) <- rownames(snp_geno_df)
write.csv(t_snp_geno_df, file="Arabidopsis_geno_t.txt")
```

```{r}
#Read in data and conduct PCA to detect population structure
genRaw <- fread("Arabidopsis_geno_t.txt", sep=",")
pheRaw <- fread("Arabidopsis_pheno.txt", sep=",")
convert <- function(x) as.numeric(factor(x, levels = names(sort(-table(x)))))
gen_only <- genRaw[2:dim(genRaw)[1],5:dim(genRaw)[2]]
num_geno <- as.data.frame(lapply(gen_only, FUN = convert))
num_geno_t <- t(num_geno)
num_geno_t <- as.data.frame(num_geno_t)
pca1 <- prcomp(num_geno_t)
ps_uncut <- pca1$x[,1:10]
```

```{r}
#Select phenotype, slice dataframes to remove NAs, and format genotypic data
pheno_col <- as.data.frame(pheno$X3_SD)
y_uncut <- pheno_col
y<-as.data.frame(y_uncut[as.vector(!is.na(y_uncut)),])
ps<- ps_uncut[as.vector(!is.na(y_uncut)),]
fin_geno <- cbind(genRaw[2:dim(genRaw)[1],1:2], num_geno[,as.vector(!is.na(y_uncut))])
geno_mat <- data.matrix(fin_geno)
```

```{r}
# Needed for ISIS EM-BLASSO and pLARmEB
multinormal<-function(y,mean,sigma)
{
  pdf_value<-(1/sqrt(2*3.14159265358979323846*sigma))*exp(-(y-mean)*(y-mean)/(2*sigma));
  return (pdf_value)
}

ebayes_EM<-function(x,z,y)
{
  n<-nrow(z);k<-ncol(z)
  
  if(abs(min(eigen(crossprod(x,x))$values))<1e-6){
    b<-solve(crossprod(x,x)+diag(ncol(x))*1e-8)%*%crossprod(x,y)
  }else{
    b<-solve(crossprod(x,x))%*%(crossprod(x,y))
  }
  
  v0<-as.numeric(crossprod((y-x%*%b),(y-x%*%b))/n)
  u<-matrix(rep(0,k),k,1)
  v<-matrix(rep(0,k),k,1)
  s<-matrix(rep(0,k),k,1)
  for(i in 1:k)
  {
    zz<-z[,i]
    s[i]<-((crossprod(zz,zz)+1e-100)^(-1))*v0
    u[i]<-s[i]*crossprod(zz,(y-x%*%b))/v0
    v[i]<-u[i]^2+s[i]
  }
  
  vv<-matrix(rep(0,n*n),n,n);
  for(i in 1:k)
  {
    zz<-z[,i]
    vv=vv+tcrossprod(zz,zz)*v[i]
  }
  vv<-vv+diag(n)*v0
  
  iter<-0;err<-1000;iter_max<-200;err_max<-1e-8
  tau<-0;omega<-0
  while((iter<iter_max)&&(err>err_max))
  {
    iter<-iter+1
    v01<-v0
    v1<-v
    b1<-b
    vi<-solve(vv)
    xtv<-crossprod(x,vi)
    
    if(ncol(x)==1)
    {
      b<-((xtv%*%x)^(-1))*(xtv%*%y)
    }else{
      if(abs(min(eigen(xtv%*%x)$values))<1e-6){
        b<-solve((xtv%*%x)+diag(ncol(x))*1e-8)%*%(xtv%*%y)
      }else{
        b<-solve(xtv%*%x)%*%(xtv%*%y)
      }
    }
    r<-y-x%*%b
    ss<-matrix(rep(0,n),n,1)
    for(i in 1:k)
    {
      zz<-z[,i]
      zztvi<-crossprod(zz,vi)
      u[i]<-v[i]*zztvi%*%r
      s[i]<-v[i]*(1-zztvi%*%zz*v[i])
      v[i]<-(u[i]^2+s[i]+omega)/(tau+3)
      ss<-ss+zz*u[i]
    }
    v0<-as.numeric(crossprod(r,(r-ss))/n)
    
    vv<-matrix(rep(0,n*n),n,n)
    for(i in 1:k)
    {
      zz<-z[,i]
      vv<-vv+tcrossprod(zz,zz)*v[i]
    }
    vv<-vv+diag(n)*v0
    
    err<-(crossprod((b1-b),(b1-b))+(v01-v0)^2+crossprod((v1-v),(v1-v)))/(2+k)
    beta<-t(b)
    sigma2<-v0
  }
  
  wang<-matrix(rep(0,k),k,1)
  for (i in 1:k){
    stderr<-sqrt(s[i]+1e-20)
    t<-abs(u[i])/stderr
    f<-t*t
    p<-1-pchisq(f,1)
    wang[i]<-p
  }
  
  return(list(u=u,sigma2=sigma2,wang=wang))
}

likelihood<-function(xxn,xxx,yn,bbo)
{
  nq<-ncol(xxx)
  ns<-nrow(yn)
  at1<-0
  
  if(is.null(bbo)==TRUE){
    ww1<-1:ncol(xxx)
    ww1<-as.matrix(ww1)
  }else{
    ww1<-as.matrix(which(abs(bbo)>1e-5))
  }
  at1<-dim(ww1)[1]
  lod<-matrix(rep(0,nq),nq,1)
  if(at1>0.5)
    ad<-cbind(xxn,xxx[,ww1])
  else
    ad<-xxn
  if(abs(min(eigen(crossprod(ad,ad))$values))<1e-6)
    bb<-solve(crossprod(ad,ad)+diag(ncol(ad))*0.01)%*%crossprod(ad,yn)
  else
    bb<-solve(crossprod(ad,ad))%*%crossprod(ad,yn)
  vv1<-as.numeric(crossprod((yn-ad%*%bb),(yn-ad%*%bb))/ns);
  ll1<-sum(log(abs(multinormal(yn,ad%*%bb,vv1))))
  sub<-1:ncol(ad);
  if(at1>0.5)
  {
    for(i in 1:at1)
    {
      ij<-which(sub!=sub[i+ncol(xxn)])
      ad1<-ad[,ij]
      if(abs(min(eigen(crossprod(ad1,ad1))$values))<1e-6)
        bb1<-solve(crossprod(ad1,ad1)+diag(ncol(ad1))*0.01)%*%crossprod(ad1,yn)
      else
        bb1<-solve(crossprod(ad1,ad1))%*%crossprod(ad1,yn) 
      vv0<-as.numeric(crossprod((yn-ad1%*%bb1),(yn-ad1%*%bb1))/ns);
      ll0<-sum(log(abs(multinormal(yn,ad1%*%bb1,vv0))))
      lod[ww1[i]]<--2.0*(ll0-ll1)/(2.0*log(10))
    }
  }
  return (lod)
}

Plot<-function(plotresult=NULL,color1=NULL,color2=NULL,p_stand=NULL,method=NULL,type=NULL){
  
  Manhattan<-function(plotresult,color1,color2){
    parms<-as.data.frame(plotresult)
    mannewp<-as.numeric(parms[1,5])
    svgwline<-round(-log10(mannewp),4)  
    standline<-svgwline
    manhattan(parms,chr = "Chromosome",bp ="BPnumber",p ="P-value",snp="SNPname",col=c(color1,color2),suggestiveline=FALSE,genomewideline = standline)
  }
  
  
  QQplot1<-function(plotresult,p_stand,color1,color2){
    
    p_value<-as.matrix(plotresult)
    pvalue<-matrix(p_value,,1)
    observed<-sort(pvalue[,1])
    observed<-observed/2
    observed<-observed[which(observed!=0)]
    newobserved<-observed[which(observed<(p_stand/2))]
    lobs<--(log10(newobserved))
    expected<-c(1:length(newobserved))
    lexp<--(log10(expected/(length(pvalue)+1)))
    plot(lexp,lobs,xlim=c(0,max(lexp)),ylim=c(0,max(lobs)),xlab=expression('Expected -log'[10]*'(P)'),ylab=expression('Observed -log'[10]*'(P)'),col=color2)
    abline(0,1,col=color1)
  }
  
  QQplot2<-function(plotresult,color1,color2){
    
    ress1<-as.data.frame(plotresult)
    pvalue<-as.matrix(ress1)
    ps<-pvalue[,1]
    obs.x<-sort(ps)
    newobs.x<-obs.x[obs.x<1]
    n<-length(newobs.x)
    es<-(1:n)/(n+1)
    x<--log10(es)
    y<--log10(newobs.x)
    y<-y-0.3
    plot(x,y,xlim=c(0.3,max(x)),ylim=c(0.3,max(y)),xlab=expression('Expected -log'[10]*'(P)'),ylab=expression('Observed -log'[10]*'(P)'),col=color2)
    abline(0,1,col=color1)
    
  }
  
  
  LOD<-function(fileplot=NULL,color1,method=NULL){
    
    data<-as.matrix(plotresult)
    data<-as.data.frame(data,stringsAsFactors = F)
    gen<-data[,1:2]
    resulty<-data[,3:5]
    resultkq<-as.matrix(resulty)
    resultk<-which(resultkq=="",arr.ind = TRUE)
    resultq<-resulty[1:(resultk[1]-1),] 
    
    if(nrow(resultq)>1){
      result<-resultq
    }else{
      result<-t(as.matrix(resultq))
    }
    
    galaxyy<-as.data.frame(result)
    galaxyy<-sapply(galaxyy,as.numeric)
    chr_pos <- gen[,1:2]
    chr_pos<-sapply(chr_pos,as.numeric)
    
    chr_num <- length(unique(chr_pos[,1]))
    chr <- matrix(0,chr_num,1)
    pos <- matrix(0,chr_num,1)
    for(i in 1:chr_num)
    {
      
      temp <- numeric()
      temp <- length(which(chr_pos[,1]==i))
      if(i==1)
      {
        pos[i] <- temp
        chr[i] <- chr_pos[pos[i],2]
      }else{
        pos[i] <- pos[i-1] + temp
        chr[i] <- chr_pos[pos[i],2]
      }
    }
    
    pos_acc <- matrix(0,chr_num,1)
    for(i in 1:chr_num)
    {
      if(i==1){
        pos_acc[i] <- chr[i]
      }else{
        pos_acc[i] <- pos_acc[i-1] + chr[i]
      }
    }
    
    newres_pos <- galaxyy[,2]
    res_sumpos <- pos_acc[galaxyy[which(galaxyy[,1]>1),1]-1] + galaxyy[which(galaxyy[,1]>1),2] 
    newres_pos[which(galaxyy[,1]>1)] <- res_sumpos 
    pospic<-c(newres_pos)
    lodpic<-c(galaxyy[,3])  
    mm<-round(max(pospic)/4000)
    mm<-as.numeric(format(mm,digits = 1,scientific = TRUE))
    pospicx<-pospic/mm
    if(pospicx[1]<20){
      pospicx[1]<-pospicx[1]+20
    }
    pos_acc1<-pos_acc/mm
    resdf1 <- data.frame(pospicx,lodpic)
    
    pp <- ggplot(data=resdf1, aes(x=pospicx, y=lodpic)) +
      geom_bar(stat="identity", width=0.5, fill="white", linetype="solid",color=color1)
    
    pp <- pp + geom_vline(xintercept=c(0,pos_acc1),linetype="dashed",alpha=0.2)
    pp <- pp  + scale_x_continuous(expand=c(0,0),limits=c(0,(pos_acc1[dim(pos_acc1)[1]]+100))) +
      scale_y_continuous(expand=c(0,0))
    pp <- pp + xlab(paste("Genome position (",mm,"bp)",sep = "")) + ylab("LOD score") + ggtitle("") + theme_classic()
    pp <- pp + theme(axis.title.y = element_text( vjust = 2,hjust=0.5,size = 14),
                     axis.title.x = element_text(vjust = -0.5,hjust=0.5,size = 14))
    
    pp <- pp + theme(panel.background = element_rect(fill = "white"))
    pp <- pp + theme(text=element_text(family="mono"))
    pp <- pp + theme(axis.line.y = element_line(colour = "black", linetype = "solid"),
                     axis.line.x = element_line(colour = "black", linetype = "solid"))
    print(pp)
    
  }  
  
  if(type=="Manhattan"){
    
    Manhattan(plotresult,color1,color2)
    
  }else if(type=="qq"){
    
    if(method=="FASTmrEMMA"){
      QQplot2(plotresult,color1,color2)  
    }else{
      QQplot1(plotresult,p_stand,color1,color2) 
    }
    
  }else if(type=="LOD"){
    
    LOD(plotresult,color1)
    
  }  
}


emma.kinship <- function(snps, method="additive", use="all") {
  n0 <- sum(snps==0,na.rm=TRUE)
  nh <- sum(snps==0.5,na.rm=TRUE)
  n1 <- sum(snps==1,na.rm=TRUE)
  nNA <- sum(is.na(snps))
  stopifnot(n0+nh+n1+nNA == length(snps))
  if ( method == "dominant" ) {
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) > 0.5),nrow(snps),ncol(snps))
    snps[!is.na(snps) & (snps == 0.5)] <- flags[!is.na(snps) & (snps == 0.5)]
  }
  else if ( method == "recessive" ) {
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) < 0.5),nrow(snps),ncol(snps))
    snps[!is.na(snps) & (snps == 0.5)] <- flags[!is.na(snps) & (snps == 0.5)]
  }
  else if ( ( method == "additive" ) && ( nh > 0 ) ) {
    dsnps <- snps
    rsnps <- snps
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) > 0.5),nrow(snps),ncol(snps))
    dsnps[!is.na(snps) & (snps==0.5)] <- flags[!is.na(snps) & (snps==0.5)]
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) < 0.5),nrow(snps),ncol(snps))
    rsnps[!is.na(snps) & (snps==0.5)] <- flags[!is.na(snps) & (snps==0.5)]
    snps <- rbind(dsnps,rsnps)
  }
  
  if ( use == "all" ) {
    mafs <- matrix(rowMeans(snps,na.rm=TRUE),nrow(snps),ncol(snps))
    snps[is.na(snps)] <- mafs[is.na(snps)]
  }
  else if ( use == "complete.obs" ) {
    snps <- snps[rowSums(is.na(snps))==0,]
  }
  
  n <- ncol(snps)
  K <- matrix(nrow=n,ncol=n)
  diag(K) <- 1
  
  for(i in 2:n) {
    for(j in 1:(i-1)) {
      x <- snps[,i]*snps[,j] + (1-snps[,i])*(1-snps[,j])
      K[i,j] <- sum(x,na.rm=TRUE)/sum(!is.na(x))
      K[j,i] <- K[i,j]
    }
  }
  return(K)
}

emma.eigen.L <- function(Z,K,complete=TRUE) {
  if ( is.null(Z) ) {
    return(emma.eigen.L.wo.Z(K))
  }
  else {
    return(emma.eigen.L.w.Z(Z,K,complete))
  }
}
#likelihood
emma.eigen.L.wo.Z <- function(K) {
  eig <- eigen(K,symmetric=TRUE)
  return(list(values=eig$values,vectors=eig$vectors))
}
#likelihood
emma.eigen.L.w.Z <- function(Z,K,complete=TRUE) {
  if ( complete == FALSE ) {
    vids <- colSums(Z)>0
    Z <- Z[,vids]
    K <- K[vids,vids]
  }
  eig <- eigen(K%*%crossprod(Z,Z),symmetric=FALSE,EISPACK=TRUE)
  return(list(values=eig$values,vectors=qr.Q(qr(Z%*%eig$vectors),complete=TRUE)))
}

#restricted likelihood
emma.eigen.R <- function(Z,K,X,complete=TRUE) {
  if ( ncol(X) == 0 ) {
    return(emma.eigen.L(Z,K))
  }
  else if ( is.null(Z) ) {
    return(emma.eigen.R.wo.Z(K,X))
  }
  else {
    return(emma.eigen.R.w.Z(Z,K,X,complete))
  }
}
#restricted likelihood
emma.eigen.R.wo.Z <- function(K, X) {
  n <- nrow(X)
  q <- ncol(X)
  S <- diag(n)-X%*%solve(crossprod(X,X))%*%t(X)
  eig <- eigen(S%*%(K+diag(1,n))%*%S,symmetric=TRUE)
  stopifnot(!is.complex(eig$values))
  return(list(values=eig$values[1:(n-q)]-1,vectors=eig$vectors[,1:(n-q)]))
}

emma.eigen.R.w.Z <- function(Z, K, X, complete = TRUE) {
  if ( complete == FALSE ) {
    vids <-  colSums(Z) > 0
    Z <- Z[,vids]
    K <- K[vids,vids]
  }
  n <- nrow(Z)
  t <- ncol(Z)
  q <- ncol(X)
  
  SZ <- Z - X%*%solve(crossprod(X,X))%*%crossprod(X,Z)
  eig <- eigen(K%*%crossprod(Z,SZ),symmetric=FALSE)
  if ( is.complex(eig$values) ) {
    eig$values <- Re(eig$values)
    eig$vectors <- Re(eig$vectors)    
  }
  qr.X <- qr.Q(qr(X))
  return(list(values=eig$values[1:(t-q)],
              vectors=qr.Q(qr(cbind(SZ%*%eig$vectors[,1:(t-q)],qr.X)),
                           complete=TRUE)[,c(1:(t-q),(t+1):n)]))   
}

emma.delta.ML.LL.wo.Z <- function(logdelta, lambda, etas, xi) {
  n <- length(xi)
  delta <- exp(logdelta)
  return( 0.5*(n*(log(n/(2*pi))-1-log(sum((etas*etas)/(delta*lambda+1))))-sum(log(delta*xi+1))) )  
}

emma.delta.ML.LL.w.Z <- function(logdelta, lambda, etas.1, xi.1, n, etas.2.sq ) {
  delta <- exp(logdelta)
  return( 0.5*(n*(log(n/(2*pi))-1-log(sum(etas.1*etas.1/(delta*lambda+1))+etas.2.sq))-sum(log(delta*xi.1+1)) ))
  
}

emma.delta.ML.dLL.wo.Z <- function(logdelta, lambda, etas, xi) {
  n <- length(xi)
  delta <- exp(logdelta)
  etasq <- etas*etas
  ldelta <- delta*lambda+1
  return( 0.5*(n*sum(etasq*lambda/(ldelta*ldelta))/sum(etasq/ldelta)-sum(xi/(delta*xi+1))) )
}

emma.delta.ML.dLL.w.Z <- function(logdelta, lambda, etas.1, xi.1, n, etas.2.sq ) {
  delta <- exp(logdelta)
  etasq <- etas.1*etas.1
  ldelta <- delta*lambda+1
  return( 0.5*(n*sum(etasq*lambda/(ldelta*ldelta))/(sum(etasq/ldelta)+etas.2.sq)-sum(xi.1/(delta*xi.1+1))) )
}

emma.delta.REML.LL.wo.Z <- function(logdelta, lambda, etas) {
  nq <- length(etas)
  delta <-  exp(logdelta)
  return( 0.5*(nq*(log(nq/(2*pi))-1-log(sum(etas*etas/(delta*lambda+1))))-sum(log(delta*lambda+1))) )
}

emma.delta.REML.LL.w.Z <- function(logdelta, lambda, etas.1, n, t, etas.2.sq ) {
  tq <- length(etas.1)
  nq <- n - t + tq
  delta <-  exp(logdelta)
  return( 0.5*(nq*(log(nq/(2*pi))-1-log(sum(etas.1*etas.1/(delta*lambda+1))+etas.2.sq))-sum(log(delta*lambda+1))) ) 
}

emma.delta.REML.dLL.wo.Z <- function(logdelta, lambda, etas) {
  nq <- length(etas)
  delta <- exp(logdelta)
  etasq <- etas*etas
  ldelta <- delta*lambda+1
  return( 0.5*(nq*sum(etasq*lambda/(ldelta*ldelta))/sum(etasq/ldelta)-sum(lambda/ldelta)) )
}

emma.delta.REML.dLL.w.Z <- function(logdelta, lambda, etas.1, n, t1, etas.2.sq ) {
  t <- t1
  tq <- length(etas.1)
  nq <- n - t + tq
  delta <- exp(logdelta)
  etasq <- etas.1*etas.1
  ldelta <- delta*lambda+1
  return( 0.5*(nq*sum(etasq*lambda/(ldelta*ldelta))/(sum(etasq/ldelta)+etas.2.sq)-sum(lambda/ldelta) ))
}


emma.MLE <- function(y, X, K, Z=NULL, ngrids=100, llim=-10, ulim=10,
                     esp=1e-10, eig.L = NULL, eig.R = NULL)
{
  n <- length(y)
  t <- nrow(K)
  q <- ncol(X)
  stopifnot(ncol(K) == t)
  stopifnot(nrow(X) == n)
  if ( det(crossprod(X,X)) == 0 ) {
    warning("X is singular")
    return (list(ML=0,delta=0,ve=0,vg=0))
  }
  
  if ( is.null(Z) ) {
    if ( is.null(eig.L) ) {
      eig.L <- emma.eigen.L.wo.Z(K)
    }
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.wo.Z(K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1<-matrix(eig.R$values,n-q,m)    
    Lambdas <- Lambdas.1 * matrix(delta,n-q,m,byrow=TRUE)+1
    Xis.1<-matrix(eig.L$values,n,m)
    Xis <- Xis.1* matrix(delta,n,m,byrow=TRUE)+1
    Etasq <- matrix(etas*etas,n-q,m)
    dLL <- 0.5*delta*(n*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/colSums(Etasq/Lambdas)-colSums(Xis.1/Xis))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.ML.LL.wo.Z(llim,eig.R$values,etas,eig.L$values))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.ML.LL.wo.Z(ulim,eig.R$values,etas,eig.L$values))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.ML.dLL.wo.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas=etas, xi=eig.L$values)
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.ML.LL.wo.Z(r$root,eig.R$values, etas, eig.L$values))
      }
    }
  }
  else {
    if ( is.null(eig.L) ) {
      eig.L <- emma.eigen.L.w.Z(Z,K)
    }
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.w.Z(Z,K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    etas.1 <- etas[1:(t-q)]
    etas.2 <- etas[(t-q+1):(n-q)]
    etas.2.sq <- sum(etas.2*etas.2)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1<-matrix(eig.R$values,t-q,m)
    Lambdas <- Lambdas.1 * matrix(delta,t-q,m,byrow=TRUE) + 1
    Xis.1<-matrix(eig.L$values,t,m)
    Xis <- Xis.1 * matrix(delta,t,m,byrow=TRUE) + 1
    Etasq <- matrix(etas.1*etas.1,t-q,m)
    dLL <- 0.5*delta*(n*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/(colSums(Etasq/Lambdas)+etas.2.sq)-colSums(Xis.1/Xis))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.ML.LL.w.Z(llim,eig.R$values,etas.1,eig.L$values,n,etas.2.sq))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.ML.LL.w.Z(ulim,eig.R$values,etas.1,eig.L$values,n,etas.2.sq))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.ML.dLL.w.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas.1=etas.1, xi.1=eig.L$values, n=n, etas.2.sq = etas.2.sq )
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.ML.LL.w.Z(r$root,eig.R$values, etas.1, eig.L$values, n, etas.2.sq ))
      }
    }
  }
  maxdelta <- exp(optlogdelta[which.max(optLL)])
  optLL=replaceNaN(optLL)
  maxLL <- max(optLL)
  if ( is.null(Z) ) {
    maxve <- sum(etas*etas/(maxdelta*eig.R$values+1))/n    
  }
  else {
    maxve <- (sum(etas.1*etas.1/(maxdelta*eig.R$values+1))+etas.2.sq)/n
  }
  maxvg <- maxve*maxdelta
  
  return (list(ML=maxLL,delta=maxdelta,ve=maxve,vg=maxvg))
}

emma.REMLE <- function(y, X, K, Z=NULL, ngrids=100, llim=-10, ulim=10,
                       esp=1e-10, eig.L = NULL, eig.R = NULL) {
  n <- length(y)
  t <- nrow(K)
  q <- ncol(X)
  stopifnot(ncol(K) == t)
  stopifnot(nrow(X) == n)
  if ( det(crossprod(X,X)) == 0 ) {
    warning("X is singular")
    return (list(REML=0,delta=0,ve=0,vg=0))
  }
  
  if ( is.null(Z) ) {
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.wo.Z(K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1<-matrix(eig.R$values,n-q,m)
    Lambdas <- Lambdas.1 * matrix(delta,n-q,m,byrow=TRUE) + 1
    Etasq <- matrix(etas*etas,n-q,m)
    dLL <- 0.5*delta*((n-q)*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/colSums(Etasq/Lambdas)-colSums(Lambdas.1/Lambdas))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.REML.LL.wo.Z(llim,eig.R$values,etas))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.REML.LL.wo.Z(ulim,eig.R$values,etas))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.REML.dLL.wo.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas=etas)
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.REML.LL.wo.Z(r$root,eig.R$values, etas))
      }
    }
  }
  else {
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.w.Z(Z,K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    etas.1 <- etas[1:(t-q)]
    etas.2 <- etas[(t-q+1):(n-q)]
    etas.2.sq <- sum(etas.2*etas.2)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1 <- matrix(eig.R$values,t-q,m) 
    Lambdas <- Lambdas.1 * matrix(delta,t-q,m,byrow=TRUE) + 1
    Etasq <- matrix(etas.1*etas.1,t-q,m)
    dLL <- 0.5*delta*((n-q)*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/(colSums(Etasq/Lambdas)+etas.2.sq)-colSums(Lambdas.1/Lambdas))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.REML.LL.w.Z(llim,eig.R$values,etas.1,n,t,etas.2.sq))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.REML.LL.w.Z(ulim,eig.R$values,etas.1,n,t,etas.2.sq))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.REML.dLL.w.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas.1=etas.1, n=n, t1=t, etas.2.sq = etas.2.sq )
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.REML.LL.w.Z(r$root,eig.R$values, etas.1, n, t, etas.2.sq ))
      }
    }
  }  
  maxdelta <- exp(optlogdelta[which.max(optLL)])
  optLL=replaceNaN(optLL)
  maxLL <- max(optLL)
  if ( is.null(Z) ) {
    maxve <- sum(etas*etas/(maxdelta*eig.R$values+1))/(n-q)    
  }
  else {
    maxve <- (sum(etas.1*etas.1/(maxdelta*eig.R$values+1))+etas.2.sq)/(n-q)
  }
  maxvg <- maxve*maxdelta
  return (list(REML=maxLL,delta=maxdelta,ve=maxve,vg=maxvg))
}


emma.maineffects.B<-function(Z=NULL,K,deltahat.g,complete=TRUE){
  if( is.null(Z) ){
    return(emma.maineffects.B.Zo(K,deltahat.g))
  }
  else{
    return(emma.maineffects.B.Z(Z,K,deltahat.g,complete))
  }
}


emma.maineffects.B.Zo <-function(K,deltahat.g){
  t <- nrow(K)
  stopifnot(ncol(K) == t)
  B<-deltahat.g*K+diag(1,t)
  eig<-eigen(B,symmetric=TRUE)
  qr.B<-qr(B)
  q<-qr.B$rank
  stopifnot(!is.complex(eig$values))
  A<-diag(1/sqrt(eig$values[1:q]))
  Q<-eig$vectors[,1:q]
  C<-Q%*%A%*%t(Q)
  return(list(mC=C,Q=Q,A=A))
}

emma.maineffects.B.Z <- function(Z,K,deltahat.g,complete=TRUE){
  if ( complete == FALSE ) {
    vids <- colSums(Z)>0
    Z <- Z[,vids]
    K <- K[vids,vids]
  }
  n <- nrow(Z)  
  B <- deltahat.g*Z%*%K%*%t(Z)+diag(1,n)
  eig <- eigen(B,symmetric=TRUE,EISPACK=TRUE)
  qr.B<-qr(B)
  q<-qr.B$rank
  stopifnot(!is.complex(eig$values))
  A<-diag(1/sqrt(eig$values[1:q]))
  Q<-eig$vectors[,1:q]
  C<-Q%*%A%*%t(Q)
  return(list(mC=C,Q=Q,A=A,complete=TRUE))
}
emma.MLE0.c <- function(Y_c,W_c){
  n <- length(Y_c)
  stopifnot(nrow(W_c)==n)
  M_c<-diag(1,n)-W_c%*%solve(crossprod(W_c,W_c))%*%t(W_c)
  etas<-crossprod(M_c,Y_c)
  LL <- 0.5*n*(log(n/(2*pi))-1-log(sum(etas*etas)))
  return(list(ML=LL))
}

emma.REMLE0.c <- function(Y_c,W_c){
  n <- length(Y_c)
  stopifnot(nrow(W_c)==n)
  M_c <-diag(1,n)-W_c%*%solve(crossprod(W_c,W_c))%*%t(W_c)
  eig <-eigen(M_c)
  t <-qr(W_c)$rank
  v <-n-t
  U_R <-eig$vector[,1:v]
  etas<-crossprod(U_R,Y_c)
  LL <- 0.5*v*(log(v/(2*pi))-1-log(sum(etas*etas)))
  return(list(REML=LL))
}

replaceNaN<-  function(LL) {
  index=(LL=="NaN")
  if(length(index)>0) theMin=min(LL[!index])
  if(length(index)<1) theMin="NaN"
  LL[index]=theMin
  return(LL)    
}

```


```{r}
# Run ISIS EM-BLASSO
gen <- geno_mat
phe <- y
outATCG<-NULL
genRaw <- genRaw
kk <- gkin
psmatrix <- ps
svpal <- 0.05
svmlod <- 3
Genformat <- 1
CLO <- 2

pvalue<-svpal
svlod<-svmlod
inputform<-Genformat
time1 <- proc.time()

if(is.null(psmatrix)){
  flagps<-1
}else{
  flagps<-0
}

y<-phe
ps<-psmatrix


if(is.null(svpal)==TRUE||is.null(svmlod)==TRUE){
  warning("Please set parameters!")
}

if((svpal<0)||(svpal>1))
{
  warning("Please input critical P-value between 0 and 1!")
}
if(svmlod<0)
{
  warning("Please input critical LOD score: > 0 !")
}
if(is.null(gen)==TRUE)
{
  warning("Please input correct genotypic dataset !","Warning",icon="warning")
  
}
if(is.null(y)==TRUE)
{
  warning("Please input correct phenotypic dataset !","Warning",icon="warning")
  
}

if((is.null(gen)==FALSE)&&(is.null(y)==FALSE)&&(ncol(gen)!=(nrow(y)+2)))
{
  warning("Sample size in genotypic dataset doesn't equal to the sample size in phenotypic dataset!","Error",icon="error")
  
}

if((is.null(gen)==FALSE)&&(is.null(y)==FALSE)&&((ncol(gen)==(nrow(y)+2)))&&(svpal>=0)&&(svpal<=1)&&(svmlod>=0))
{
  
  wan<-NULL
  result<-NULL
  X<-t(gen)
  
  set.seed(1)
  X1<-X[3:nrow(X),]
  sig<-seq(1:ncol(X1))
  x<-data.frame(X1)
  y<-as.matrix(y)
  le<-length(sig)
  xnew<-x[sig]
  pval<-pvalue
  y1<-matrix(nrow=nrow(y),ncol=ncol(y))
  
  ps1 <- proc.time()
  
  if (is.null(ps)==FALSE)
  {
    ps1<-cbind(matrix(1,nrow=nrow(y)),ps)
    vhat<-solve(crossprod(ps1,ps1))%*%crossprod(ps1,y)
    vhat1<-vhat[-1]
    y1<-y-ps%*%vhat1
  }else{
    y1<-y
  }
  y1<-as.matrix(y1)
  
  xxx<-xnew
  mat<-vector()
  matcor<-vector()
  
  cl.cores <- detectCores()
  if((cl.cores<=2)||(is.null(CLO)==FALSE)){
    cl.cores<-1
  }else if(cl.cores>2){
    if(cl.cores>10){
      cl.cores<-10
    }else {
      cl.cores <- detectCores()-1
    }
  }
  
  cl <- makeCluster(cl.cores)
  registerDoParallel(cl)
  
  
  mm=foreach(i=1:le, .multicombine=TRUE, .combine = 'rbind')%dopar%
  {
    if (var(xxx[,i])>0){
      mat[i]<-cor.test(xxx[,i],y1)$p.value
      matcor[i]<-abs(cor(xxx[,i],y1))
      m<-c(mat[i],matcor[i])
    }else{
      mat[i]<-1
      matcor[i]<-0
      m<-c(mat[i],matcor[i])
    }
  }
  rownames(mm)<-NULL
  mat<-mm[,1];matcor<-mm[,2]
  
  stopCluster(cl)
  
  
  if(length(which(mat<pval))<=nrow(y)){
    ee<-as.vector(which(mat<pval))
  }else{
    n1<-nrow(y1)-1
    ee<-as.vector(which(rank(matcor)>=(le-n1), arr.ind=T))
  }
  
  xxxnew<-X1[,sig[ee]]
  yyy<-y1
  
  cvfit1 <- ncvreg::cv.ncvreg(scale(xxxnew), yyy, family="gaussian",penalty="SCAD",gamma=3.7,warn=FALSE)
  
  
  fit1 <- cvfit1$fit
  obj11 <- (as.vector(fit1$beta[,cvfit1$min]))
  obj1<-obj11[-1]
  if (length(which(abs(obj1)!=0))!=0)
  {
    sig1a<-which(abs(obj1)!=0)
    sig1b<-sig[-(sig[ee][sig1a])]
    yyy1<-y1-(X1[,sig[ee][sig1a]]%*%as.matrix(obj1[sig1a]))
    xxx1<-X1[,sig1b]
    mat1<-vector()
    for (i in 1:length(sig1b))
    {
      if (var(xxx1[,i])>0){
        
        mat1[i]<-abs(cor(xxx1[,i],yyy1))
      }else{
        mat1[i]<-0
        
      }
    }
    
    n2<-nrow(yyy1)-1
    ee1<-as.vector(which(rank(mat1)>=(ncol(xxx1)-n2), arr.ind=T))
    
    xxxnew1<-X1[,sig1b[ee1]]
    cvfit2 <- ncvreg::cv.ncvreg(scale(xxxnew1), yyy1, family="gaussian",penalty="SCAD",gamma=3.7,warn=FALSE)
    
    
    fit2 <- cvfit2$fit
    obj22 <- (as.vector(fit2$beta[,cvfit2$min]))
    obj2<-obj22[-1]
    sig1c<-sig1b[ee1][which(abs(obj2)!=0)]
    sigg<-sort(c(sig[ee][sig1a],sig1c))
    
  }else{
    
    sigg<-sig[ee]
  }
  le1<-length(sigg)
  
  if(le1!=0){
    
    ###########if result just have one column##############modified 2017.3.22###############
    if(le1==1){
      xxxnew11<-matrix(X1[,sigg],,1)
    }else{
      xxxnew11<-X1[,sigg]
    }
    
    z<-matrix()
    
    if (is.null(ps)==TRUE)
    {
      z<-matrix(1,nrow(X1),1)
    }else{
      z<-cbind(matrix(1,nrow(X1),1),ps)
    }
    
    u1<-ebayes_EM(z,xxxnew11,y)
    obj3<-u1$u
    result1<-matrix(0,ncol(X1)*1,ncol=1,nrow=ncol(X1))
    for (i in 1: le1)
    {
      result1[(sigg)[i],1]=obj3[i]
    }
    Res<- t(as.matrix((rowSums(result1)/ncol(result1))))
    Res1<-as.vector(Res)
    le2<-length(which(abs(Res1)>1e-5))
    
    if(le2!=0){
      
      sig1<-which(abs(Res1)>1e-5)
      bbo<-matrix(0,le2,1)
      for (i in 1:le2){
        bbo[i,]=Res1[sig1[i]]
      }
      
      her1<-vector(length=le2)
      for (i in 1:le2){
        p1<-length(as.vector(which(X1[,sig1[i]]==1)))/length(X1[,sig1[i]])
        p2<-1-p1
        her1[i]=((p1+p2)-(p1-p2)^2)*(Res1[sig1[i]])^2
      }
      
      if(var(y)>=sum(her1)+u1$sigma2){
        her<-(her1/as.vector(var(y)))*100
        
      }else{
        her<-(her1/(sum(her1)+u1$sigma2))*100
      }
      
      if(length(sig1)!= 0){
        
        if(length(sig1)==1){
          xxxx<-as.matrix(X1[,sig1])
          
        }else{
          xxxx<-X1[,sig1]
        }
        
        yn<-as.matrix(y)
        xxn<-z
        
        lod<-likelihood(xxn,xxxx,yn,bbo)
        slod<-cbind(sig1,lod,her)
        
        if(length(which(slod[,2]>=svlod))>=1){
          
          if(length(which(slod[,2]>=svlod))==1){
            sslod<-t(as.matrix(slod[which(slod[,2]>=svlod),]))
            sig1<-slod[which(slod[,2]>=svlod),1]
          }else if(length(which(slod[,2]>=svlod))>1){
            sslod<-slod[which(slod[,2]>=svlod),]
            sig1<-sslod[,1]
          }
          xxxx<-as.matrix(X1[,sig1])
          lod<-sslod[,2]
          her<-sslod[,3]
          
          ii<-as.vector(sig1)
          qqq<-matrix(0,nrow=length(ii),ncol=6)
          qqq[,1]=as.matrix(ii)
          for (j in 1:length(ii)){
            qqq[j,2]=X[1,ii[j]]
            qqq[j,3]=X[2,ii[j]]
            qqq[j,4]=result1[ii[j],]
            
            qqq[j,5]=lod[j]
            qqq[j,6]=her[j]
          }
          id<-which(qqq[,5]==0)
          
          if(length(id)!=dim(qqq)[1]){
            
            if(length(id)!=0){
              qqq1<-qqq[-id,]
            }else{
              qqq1<-qqq
            }
            #######revised 2017 3.4##############################
            if(length(sig1)==1){
              xxmaf<-t(xxxx)
              xxmaf<-matrix(xxmaf,1,)
              result<-matrix(qqq1[,-1],1,)
            }else{
              xxmaf<-t(xxxx)
              result<-as.matrix(qqq1[,-1])
            }
            
            leng.maf<-dim(xxmaf)[2]
            
            maf.fun<-function(snp){
              leng<-length(snp)
              snp1<-length(which(snp==1))
              snp11<-length(which(snp==-1))
              snp0<-length(which(snp==0))
              ma1<-(2*snp1+snp0)/(2*leng)
              ma2<-(2*snp11+snp0)/(2*leng)
              maf<-min(ma1,ma2)
              return(maf)
            }
            
            maf<-apply(xxmaf,1,maf.fun)
            maf<-as.matrix(round(maf,4))
            vee<-round(u1$sigma2,4)
            pee<-round(var(y),4)
            
            if(nrow(qqq1)>1){
              
              vees<-matrix("",nrow = nrow(result),1)
              pees<-matrix("",nrow = nrow(result),1)
              pees[1,1]<-pee
              vees[1,1]<-vee
              result<-as.matrix(qqq1[,-1])
              result<-result
              temp<-as.matrix(result[,3:5])
              temp[which(abs(temp)>=1e-4)]<-round(temp[abs(temp)>=1e-4],4)
              temp[which(abs(temp)<1e-4)]<-as.numeric(sprintf("%.4e",temp[abs(temp)<1e-4]))
              wan<-cbind(result[,1:2],temp)
              
            }else{
              pees<-as.matrix(pee)
              vees<-as.matrix(vee)
              result<-t(as.matrix(qqq1[,-1]))
              result<-result
              temp<-t(as.matrix(result[,3:5]))
              temp[which(abs(temp)>=1e-4)]<-round(temp[abs(temp)>=1e-4],4)
              temp[which(abs(temp)<1e-4)]<-as.numeric(sprintf("%.4e",temp[abs(temp)<1e-4]))
              wan<-cbind(t(as.matrix(result[,1:2])),temp)
              
            }
            
            if(inputform==1){
              genRaw<-as.data.frame(genRaw)
              genraw<-genRaw[-1,1:4]
              
              wan_len<-dim(wan)[1]
              marker<-character()
              snp<-character()
              
              for(i in 1:wan_len){
                chr_pos<-which(genraw[,2]==wan[i,1])
                new_matrix<-genraw[chr_pos,]
                posi_pos<-which(new_matrix[,3]==wan[i,2])
                mark<-matrix(new_matrix[posi_pos,1],1,)
                marker<-rbind(marker,mark)
                sn<-matrix(new_matrix[posi_pos,4],1,)
                snp<-rbind(snp,sn)
              }
            }
            if(inputform==2){
              
              genRaw<-as.data.frame(genRaw)
              genraw<-genRaw[-1,1:4]
              
              wan_len<-dim(wan)[1]
              marker<-character()
              snp<-character()
              for(i in 1:wan_len){
                chr_pos<-which(genraw[,2]==wan[i,1])
                new_matrix<-genraw[chr_pos,]
                posi_pos<-which(new_matrix[,3]==wan[i,2])
                mark<-matrix(new_matrix[posi_pos,1],1,)
                marker<-rbind(marker,mark)
                sn<-matrix(new_matrix[posi_pos,4],1,)
                snp<-rbind(snp,sn)
              }
              
            }
            if(inputform==3){
              genRaw<-as.data.frame(genRaw)
              genraw<-genRaw[-1,c(1,3,4,12)]
              
              wan_len<-dim(wan)[1]
              marker<-character()
              snp<-character()
              for(i in 1:wan_len){
                chr_pos<-which(genraw[,2]==wan[i,1])
                new_matrix<-genraw[chr_pos,]
                posi_pos<-which(new_matrix[,3]==wan[i,2])
                mark<-matrix(new_matrix[posi_pos,1],1,)
                marker<-rbind(marker,mark)
                sn<-matrix(new_matrix[posi_pos,4],1,)
                snp<-rbind(snp,sn)
              }
            }
            
            #wan<-cbind(marker,wan,maf,snp,vees,pees)
            #tempwan <- wan
            #lodscore1 <- as.numeric(tempwan[,5])
            #log10P <- as.matrix(round(-log10(1-pchisq(lodscore1*4.605,1)),4))
            
            #if(nrow(tempwan)>1){
            #  tempwan1 <- cbind(tempwan[,1:5],log10P,tempwan[,6:10])
            #}else{
            #  tempwan1 <- cbind(t(as.matrix(tempwan[,1:5])),log10P,t(as.matrix(tempwan[,6:10])))
            #}
            
            #wan <- tempwan1
            
            #colnames(wan)<-c("RS#","Chromosome","Marker Position (bp)","QTN effect","LOD score","-log10(P)","r2 (%)","MAF","Genotype  for code 1","Var_Error","Var_phen (total)")
          }
        }
      }
    }
  }
  
  #if(nrow(result)>1){
  #  r1<-as.matrix(result[,c(1,2,4)])
  #}else{
  #  r1<-t(as.matrix(result[,c(1,2,4)]))
  }
  #r2<-as.matrix(gen[,1:2])
  
  #rowbl<-nrow(r2)-nrow(r1)
  #bl<-matrix("",rowbl,3)
  #r12<-rbind(r1,bl)
  #result<-cbind(r2,r12)
  
  #colnames(result)<-c("Chromosome","Marker Position (bp)","Chromosome(detected)","Marker Position (bp)(detected)","LOD score(detected)")
  
  #3output<-list(result=wan,plot=result)
  
  #3return(output)
  

time2 <- proc.time()
time_diff <- time2-time1
final_res <- data.frame(SNP_Index=numeric(), Chromosome=integer(), Genome_Position=numeric(),
                        Chromosome_Position=numeric(), QTL=numeric(), LOD=numeric(), P_val=numeric())
for (i in 1:dim(result)[1]){
  index <- result[i,1]
  chr <- geno@chromosome[index]
  map_pos <- geno@map[index]
  per_chrom_pos <- per_chrom(map_pos)
  QTL_indiv <- result[i,3]
  LOD_indiv <- result[i,4]
  P_val_indiv <- result[i,5]
  row_res <- cbind(index, chr, map_pos, per_chrom_pos, QTL_indiv,LOD_indiv,P_val_indiv)
  final_res <- rbind(final_res, row_res)
}  

write.csv(final_res, "ISIS_res_SD.csv")

plot(geno@map, result1, col=geno@chromosome, xlab="Map Position", ylab="QTL effect", main="ISIS EM-BLASSO GWAS of Phenotype SD")

```

```{r}
multinormal<-function(y,mean,sigma)
{
  pdf_value<-(1/sqrt(2*3.14159265358979323846*sigma))*exp(-(y-mean)*(y-mean)/(2*sigma));
  return (pdf_value)
}

ebayes_EM<-function(x,z,y)
{
  n<-nrow(z);k<-ncol(z)
  
  if(abs(min(eigen(crossprod(x,x))$values))<1e-6){
    b<-solve(crossprod(x,x)+diag(ncol(x))*1e-8)%*%crossprod(x,y)
  }else{
    b<-solve(crossprod(x,x))%*%(crossprod(x,y))
  }
  
  v0<-as.numeric(crossprod((y-x%*%b),(y-x%*%b))/n)
  u<-matrix(rep(0,k),k,1)
  v<-matrix(rep(0,k),k,1)
  s<-matrix(rep(0,k),k,1)
  for(i in 1:k)
  {
    zz<-z[,i]
    s[i]<-((crossprod(zz,zz)+1e-100)^(-1))*v0
    u[i]<-s[i]*crossprod(zz,(y-x%*%b))/v0
    v[i]<-u[i]^2+s[i]
  }
  
  vv<-matrix(rep(0,n*n),n,n);
  for(i in 1:k)
  {
    zz<-z[,i]
    vv=vv+tcrossprod(zz,zz)*v[i]
  }
  vv<-vv+diag(n)*v0
  
  iter<-0;err<-1000;iter_max<-200;err_max<-1e-8
  tau<-0;omega<-0
  while((iter<iter_max)&&(err>err_max))
  {
    iter<-iter+1
    v01<-v0
    v1<-v
    b1<-b
    vi<-solve(vv)
    xtv<-crossprod(x,vi)
    
    if(ncol(x)==1)
    {
      b<-((xtv%*%x)^(-1))*(xtv%*%y)
    }else{
      if(abs(min(eigen(xtv%*%x)$values))<1e-6){
        b<-solve((xtv%*%x)+diag(ncol(x))*1e-8)%*%(xtv%*%y)
      }else{
        b<-solve(xtv%*%x)%*%(xtv%*%y)
      }
    }
    r<-y-x%*%b
    ss<-matrix(rep(0,n),n,1)
    for(i in 1:k)
    {
      zz<-z[,i]
      zztvi<-crossprod(zz,vi)
      u[i]<-v[i]*zztvi%*%r
      s[i]<-v[i]*(1-zztvi%*%zz*v[i])
      v[i]<-(u[i]^2+s[i]+omega)/(tau+3)
      ss<-ss+zz*u[i]
    }
    v0<-as.numeric(crossprod(r,(r-ss))/n)
    
    vv<-matrix(rep(0,n*n),n,n)
    for(i in 1:k)
    {
      zz<-z[,i]
      vv<-vv+tcrossprod(zz,zz)*v[i]
    }
    vv<-vv+diag(n)*v0
    
    err<-(crossprod((b1-b),(b1-b))+(v01-v0)^2+crossprod((v1-v),(v1-v)))/(2+k)
    beta<-t(b)
    sigma2<-v0
  }
  
  wang<-matrix(rep(0,k),k,1)
  for (i in 1:k){
    stderr<-sqrt(s[i]+1e-20)
    t<-abs(u[i])/stderr
    f<-t*t
    p<-1-pchisq(f,1)
    wang[i]<-p
  }
  
  return(list(u=u,sigma2=sigma2,wang=wang))
}

likelihood<-function(xxn,xxx,yn,bbo)
{
  nq<-ncol(xxx)
  ns<-nrow(yn)
  at1<-0
  
  if(is.null(bbo)==TRUE){
    ww1<-1:ncol(xxx)
    ww1<-as.matrix(ww1)
  }else{
    ww1<-as.matrix(which(abs(bbo)>1e-5))
  }
  at1<-dim(ww1)[1]
  lod<-matrix(rep(0,nq),nq,1)
  if(at1>0.5)
    ad<-cbind(xxn,xxx[,ww1])
  else
    ad<-xxn
  if(abs(min(eigen(crossprod(ad,ad))$values))<1e-6)
    bb<-solve(crossprod(ad,ad)+diag(ncol(ad))*0.01)%*%crossprod(ad,yn)
  else
    bb<-solve(crossprod(ad,ad))%*%crossprod(ad,yn)
  vv1<-as.numeric(crossprod((yn-ad%*%bb),(yn-ad%*%bb))/ns);
  ll1<-sum(log(abs(multinormal(yn,ad%*%bb,vv1))))
  sub<-1:ncol(ad);
  if(at1>0.5)
  {
    for(i in 1:at1)
    {
      ij<-which(sub!=sub[i+ncol(xxn)])
      ad1<-ad[,ij]
      if(abs(min(eigen(crossprod(ad1,ad1))$values))<1e-6)
        bb1<-solve(crossprod(ad1,ad1)+diag(ncol(ad1))*0.01)%*%crossprod(ad1,yn)
      else
        bb1<-solve(crossprod(ad1,ad1))%*%crossprod(ad1,yn) 
      vv0<-as.numeric(crossprod((yn-ad1%*%bb1),(yn-ad1%*%bb1))/ns);
      ll0<-sum(log(abs(multinormal(yn,ad1%*%bb1,vv0))))
      lod[ww1[i]]<--2.0*(ll0-ll1)/(2.0*log(10))
    }
  }
  return (lod)
}

Plot<-function(plotresult=NULL,color1=NULL,color2=NULL,p_stand=NULL,method=NULL,type=NULL){
  
  Manhattan<-function(plotresult,color1,color2){
    parms<-as.data.frame(plotresult)
    mannewp<-as.numeric(parms[1,5])
    svgwline<-round(-log10(mannewp),4)  
    standline<-svgwline
    manhattan(parms,chr = "Chromosome",bp ="BPnumber",p ="P-value",snp="SNPname",col=c(color1,color2),suggestiveline=FALSE,genomewideline = standline)
  }
  
  
  QQplot1<-function(plotresult,p_stand,color1,color2){
    
    p_value<-as.matrix(plotresult)
    pvalue<-matrix(p_value,,1)
    observed<-sort(pvalue[,1])
    observed<-observed/2
    observed<-observed[which(observed!=0)]
    newobserved<-observed[which(observed<(p_stand/2))]
    lobs<--(log10(newobserved))
    expected<-c(1:length(newobserved))
    lexp<--(log10(expected/(length(pvalue)+1)))
    plot(lexp,lobs,xlim=c(0,max(lexp)),ylim=c(0,max(lobs)),xlab=expression('Expected -log'[10]*'(P)'),ylab=expression('Observed -log'[10]*'(P)'),col=color2)
    abline(0,1,col=color1)
  }
  
  QQplot2<-function(plotresult,color1,color2){
    
    ress1<-as.data.frame(plotresult)
    pvalue<-as.matrix(ress1)
    ps<-pvalue[,1]
    obs.x<-sort(ps)
    newobs.x<-obs.x[obs.x<1]
    n<-length(newobs.x)
    es<-(1:n)/(n+1)
    x<--log10(es)
    y<--log10(newobs.x)
    y<-y-0.3
    plot(x,y,xlim=c(0.3,max(x)),ylim=c(0.3,max(y)),xlab=expression('Expected -log'[10]*'(P)'),ylab=expression('Observed -log'[10]*'(P)'),col=color2)
    abline(0,1,col=color1)
    
  }
  
  
  LOD<-function(fileplot=NULL,color1,method=NULL){
    
    data<-as.matrix(plotresult)
    data<-as.data.frame(data,stringsAsFactors = F)
    gen<-data[,1:2]
    resulty<-data[,3:5]
    resultkq<-as.matrix(resulty)
    resultk<-which(resultkq=="",arr.ind = TRUE)
    resultq<-resulty[1:(resultk[1]-1),] 
    
    if(nrow(resultq)>1){
      result<-resultq
    }else{
      result<-t(as.matrix(resultq))
    }
    
    galaxyy<-as.data.frame(result)
    galaxyy<-sapply(galaxyy,as.numeric)
    chr_pos <- gen[,1:2]
    chr_pos<-sapply(chr_pos,as.numeric)
    
    chr_num <- length(unique(chr_pos[,1]))
    chr <- matrix(0,chr_num,1)
    pos <- matrix(0,chr_num,1)
    for(i in 1:chr_num)
    {
      
      temp <- numeric()
      temp <- length(which(chr_pos[,1]==i))
      if(i==1)
      {
        pos[i] <- temp
        chr[i] <- chr_pos[pos[i],2]
      }else{
        pos[i] <- pos[i-1] + temp
        chr[i] <- chr_pos[pos[i],2]
      }
    }
    
    pos_acc <- matrix(0,chr_num,1)
    for(i in 1:chr_num)
    {
      if(i==1){
        pos_acc[i] <- chr[i]
      }else{
        pos_acc[i] <- pos_acc[i-1] + chr[i]
      }
    }
    
    newres_pos <- galaxyy[,2]
    res_sumpos <- pos_acc[galaxyy[which(galaxyy[,1]>1),1]-1] + galaxyy[which(galaxyy[,1]>1),2] 
    newres_pos[which(galaxyy[,1]>1)] <- res_sumpos 
    pospic<-c(newres_pos)
    lodpic<-c(galaxyy[,3])  
    mm<-round(max(pospic)/4000)
    mm<-as.numeric(format(mm,digits = 1,scientific = TRUE))
    pospicx<-pospic/mm
    if(pospicx[1]<20){
      pospicx[1]<-pospicx[1]+20
    }
    pos_acc1<-pos_acc/mm
    resdf1 <- data.frame(pospicx,lodpic)
    
    pp <- ggplot(data=resdf1, aes(x=pospicx, y=lodpic)) +
      geom_bar(stat="identity", width=0.5, fill="white", linetype="solid",color=color1)
    
    pp <- pp + geom_vline(xintercept=c(0,pos_acc1),linetype="dashed",alpha=0.2)
    pp <- pp  + scale_x_continuous(expand=c(0,0),limits=c(0,(pos_acc1[dim(pos_acc1)[1]]+100))) +
      scale_y_continuous(expand=c(0,0))
    pp <- pp + xlab(paste("Genome position (",mm,"bp)",sep = "")) + ylab("LOD score") + ggtitle("") + theme_classic()
    pp <- pp + theme(axis.title.y = element_text( vjust = 2,hjust=0.5,size = 14),
                     axis.title.x = element_text(vjust = -0.5,hjust=0.5,size = 14))
    
    pp <- pp + theme(panel.background = element_rect(fill = "white"))
    pp <- pp + theme(text=element_text(family="mono"))
    pp <- pp + theme(axis.line.y = element_line(colour = "black", linetype = "solid"),
                     axis.line.x = element_line(colour = "black", linetype = "solid"))
    print(pp)
    
  }  
  
  if(type=="Manhattan"){
    
    Manhattan(plotresult,color1,color2)
    
  }else if(type=="qq"){
    
    if(method=="FASTmrEMMA"){
      QQplot2(plotresult,color1,color2)  
    }else{
      QQplot1(plotresult,p_stand,color1,color2) 
    }
    
  }else if(type=="LOD"){
    
    LOD(plotresult,color1)
    
  }  
}


emma.kinship <- function(snps, method="additive", use="all") {
  n0 <- sum(snps==0,na.rm=TRUE)
  nh <- sum(snps==0.5,na.rm=TRUE)
  n1 <- sum(snps==1,na.rm=TRUE)
  nNA <- sum(is.na(snps))
  stopifnot(n0+nh+n1+nNA == length(snps))
  if ( method == "dominant" ) {
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) > 0.5),nrow(snps),ncol(snps))
    snps[!is.na(snps) & (snps == 0.5)] <- flags[!is.na(snps) & (snps == 0.5)]
  }
  else if ( method == "recessive" ) {
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) < 0.5),nrow(snps),ncol(snps))
    snps[!is.na(snps) & (snps == 0.5)] <- flags[!is.na(snps) & (snps == 0.5)]
  }
  else if ( ( method == "additive" ) && ( nh > 0 ) ) {
    dsnps <- snps
    rsnps <- snps
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) > 0.5),nrow(snps),ncol(snps))
    dsnps[!is.na(snps) & (snps==0.5)] <- flags[!is.na(snps) & (snps==0.5)]
    flags <- matrix(as.double(rowMeans(snps,na.rm=TRUE) < 0.5),nrow(snps),ncol(snps))
    rsnps[!is.na(snps) & (snps==0.5)] <- flags[!is.na(snps) & (snps==0.5)]
    snps <- rbind(dsnps,rsnps)
  }
  
  if ( use == "all" ) {
    mafs <- matrix(rowMeans(snps,na.rm=TRUE),nrow(snps),ncol(snps))
    snps[is.na(snps)] <- mafs[is.na(snps)]
  }
  else if ( use == "complete.obs" ) {
    snps <- snps[rowSums(is.na(snps))==0,]
  }
  
  n <- ncol(snps)
  K <- matrix(nrow=n,ncol=n)
  diag(K) <- 1
  
  for(i in 2:n) {
    for(j in 1:(i-1)) {
      x <- snps[,i]*snps[,j] + (1-snps[,i])*(1-snps[,j])
      K[i,j] <- sum(x,na.rm=TRUE)/sum(!is.na(x))
      K[j,i] <- K[i,j]
    }
  }
  return(K)
}

emma.eigen.L <- function(Z,K,complete=TRUE) {
  if ( is.null(Z) ) {
    return(emma.eigen.L.wo.Z(K))
  }
  else {
    return(emma.eigen.L.w.Z(Z,K,complete))
  }
}
#likelihood
emma.eigen.L.wo.Z <- function(K) {
  eig <- eigen(K,symmetric=TRUE)
  return(list(values=eig$values,vectors=eig$vectors))
}
#likelihood
emma.eigen.L.w.Z <- function(Z,K,complete=TRUE) {
  if ( complete == FALSE ) {
    vids <- colSums(Z)>0
    Z <- Z[,vids]
    K <- K[vids,vids]
  }
  eig <- eigen(K%*%crossprod(Z,Z),symmetric=FALSE,EISPACK=TRUE)
  return(list(values=eig$values,vectors=qr.Q(qr(Z%*%eig$vectors),complete=TRUE)))
}

#restricted likelihood
emma.eigen.R <- function(Z,K,X,complete=TRUE) {
  if ( ncol(X) == 0 ) {
    return(emma.eigen.L(Z,K))
  }
  else if ( is.null(Z) ) {
    return(emma.eigen.R.wo.Z(K,X))
  }
  else {
    return(emma.eigen.R.w.Z(Z,K,X,complete))
  }
}
#restricted likelihood
emma.eigen.R.wo.Z <- function(K, X) {
  n <- nrow(X)
  q <- ncol(X)
  S <- diag(n)-X%*%solve(crossprod(X,X))%*%t(X)
  eig <- eigen(S%*%(K+diag(1,n))%*%S,symmetric=TRUE)
  stopifnot(!is.complex(eig$values))
  return(list(values=eig$values[1:(n-q)]-1,vectors=eig$vectors[,1:(n-q)]))
}

emma.eigen.R.w.Z <- function(Z, K, X, complete = TRUE) {
  if ( complete == FALSE ) {
    vids <-  colSums(Z) > 0
    Z <- Z[,vids]
    K <- K[vids,vids]
  }
  n <- nrow(Z)
  t <- ncol(Z)
  q <- ncol(X)
  
  SZ <- Z - X%*%solve(crossprod(X,X))%*%crossprod(X,Z)
  eig <- eigen(K%*%crossprod(Z,SZ),symmetric=FALSE)
  if ( is.complex(eig$values) ) {
    eig$values <- Re(eig$values)
    eig$vectors <- Re(eig$vectors)    
  }
  qr.X <- qr.Q(qr(X))
  return(list(values=eig$values[1:(t-q)],
              vectors=qr.Q(qr(cbind(SZ%*%eig$vectors[,1:(t-q)],qr.X)),
                           complete=TRUE)[,c(1:(t-q),(t+1):n)]))   
}

emma.delta.ML.LL.wo.Z <- function(logdelta, lambda, etas, xi) {
  n <- length(xi)
  delta <- exp(logdelta)
  return( 0.5*(n*(log(n/(2*pi))-1-log(sum((etas*etas)/(delta*lambda+1))))-sum(log(delta*xi+1))) )  
}

emma.delta.ML.LL.w.Z <- function(logdelta, lambda, etas.1, xi.1, n, etas.2.sq ) {
  delta <- exp(logdelta)
  return( 0.5*(n*(log(n/(2*pi))-1-log(sum(etas.1*etas.1/(delta*lambda+1))+etas.2.sq))-sum(log(delta*xi.1+1)) ))
  
}

emma.delta.ML.dLL.wo.Z <- function(logdelta, lambda, etas, xi) {
  n <- length(xi)
  delta <- exp(logdelta)
  etasq <- etas*etas
  ldelta <- delta*lambda+1
  return( 0.5*(n*sum(etasq*lambda/(ldelta*ldelta))/sum(etasq/ldelta)-sum(xi/(delta*xi+1))) )
}

emma.delta.ML.dLL.w.Z <- function(logdelta, lambda, etas.1, xi.1, n, etas.2.sq ) {
  delta <- exp(logdelta)
  etasq <- etas.1*etas.1
  ldelta <- delta*lambda+1
  return( 0.5*(n*sum(etasq*lambda/(ldelta*ldelta))/(sum(etasq/ldelta)+etas.2.sq)-sum(xi.1/(delta*xi.1+1))) )
}

emma.delta.REML.LL.wo.Z <- function(logdelta, lambda, etas) {
  nq <- length(etas)
  delta <-  exp(logdelta)
  return( 0.5*(nq*(log(nq/(2*pi))-1-log(sum(etas*etas/(delta*lambda+1))))-sum(log(delta*lambda+1))) )
}

emma.delta.REML.LL.w.Z <- function(logdelta, lambda, etas.1, n, t, etas.2.sq ) {
  tq <- length(etas.1)
  nq <- n - t + tq
  delta <-  exp(logdelta)
  return( 0.5*(nq*(log(nq/(2*pi))-1-log(sum(etas.1*etas.1/(delta*lambda+1))+etas.2.sq))-sum(log(delta*lambda+1))) ) 
}

emma.delta.REML.dLL.wo.Z <- function(logdelta, lambda, etas) {
  nq <- length(etas)
  delta <- exp(logdelta)
  etasq <- etas*etas
  ldelta <- delta*lambda+1
  return( 0.5*(nq*sum(etasq*lambda/(ldelta*ldelta))/sum(etasq/ldelta)-sum(lambda/ldelta)) )
}

emma.delta.REML.dLL.w.Z <- function(logdelta, lambda, etas.1, n, t1, etas.2.sq ) {
  t <- t1
  tq <- length(etas.1)
  nq <- n - t + tq
  delta <- exp(logdelta)
  etasq <- etas.1*etas.1
  ldelta <- delta*lambda+1
  return( 0.5*(nq*sum(etasq*lambda/(ldelta*ldelta))/(sum(etasq/ldelta)+etas.2.sq)-sum(lambda/ldelta) ))
}


emma.MLE <- function(y, X, K, Z=NULL, ngrids=100, llim=-10, ulim=10,
                     esp=1e-10, eig.L = NULL, eig.R = NULL)
{
  n <- length(y)
  t <- nrow(K)
  q <- ncol(X)
  stopifnot(ncol(K) == t)
  stopifnot(nrow(X) == n)
  if ( det(crossprod(X,X)) == 0 ) {
    warning("X is singular")
    return (list(ML=0,delta=0,ve=0,vg=0))
  }
  
  if ( is.null(Z) ) {
    if ( is.null(eig.L) ) {
      eig.L <- emma.eigen.L.wo.Z(K)
    }
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.wo.Z(K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1<-matrix(eig.R$values,n-q,m)    
    Lambdas <- Lambdas.1 * matrix(delta,n-q,m,byrow=TRUE)+1
    Xis.1<-matrix(eig.L$values,n,m)
    Xis <- Xis.1* matrix(delta,n,m,byrow=TRUE)+1
    Etasq <- matrix(etas*etas,n-q,m)
    dLL <- 0.5*delta*(n*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/colSums(Etasq/Lambdas)-colSums(Xis.1/Xis))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.ML.LL.wo.Z(llim,eig.R$values,etas,eig.L$values))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.ML.LL.wo.Z(ulim,eig.R$values,etas,eig.L$values))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.ML.dLL.wo.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas=etas, xi=eig.L$values)
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.ML.LL.wo.Z(r$root,eig.R$values, etas, eig.L$values))
      }
    }
  }
  else {
    if ( is.null(eig.L) ) {
      eig.L <- emma.eigen.L.w.Z(Z,K)
    }
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.w.Z(Z,K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    etas.1 <- etas[1:(t-q)]
    etas.2 <- etas[(t-q+1):(n-q)]
    etas.2.sq <- sum(etas.2*etas.2)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1<-matrix(eig.R$values,t-q,m)
    Lambdas <- Lambdas.1 * matrix(delta,t-q,m,byrow=TRUE) + 1
    Xis.1<-matrix(eig.L$values,t,m)
    Xis <- Xis.1 * matrix(delta,t,m,byrow=TRUE) + 1
    Etasq <- matrix(etas.1*etas.1,t-q,m)
    dLL <- 0.5*delta*(n*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/(colSums(Etasq/Lambdas)+etas.2.sq)-colSums(Xis.1/Xis))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.ML.LL.w.Z(llim,eig.R$values,etas.1,eig.L$values,n,etas.2.sq))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.ML.LL.w.Z(ulim,eig.R$values,etas.1,eig.L$values,n,etas.2.sq))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.ML.dLL.w.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas.1=etas.1, xi.1=eig.L$values, n=n, etas.2.sq = etas.2.sq )
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.ML.LL.w.Z(r$root,eig.R$values, etas.1, eig.L$values, n, etas.2.sq ))
      }
    }
  }
  maxdelta <- exp(optlogdelta[which.max(optLL)])
  optLL=replaceNaN(optLL)
  maxLL <- max(optLL)
  if ( is.null(Z) ) {
    maxve <- sum(etas*etas/(maxdelta*eig.R$values+1))/n    
  }
  else {
    maxve <- (sum(etas.1*etas.1/(maxdelta*eig.R$values+1))+etas.2.sq)/n
  }
  maxvg <- maxve*maxdelta
  
  return (list(ML=maxLL,delta=maxdelta,ve=maxve,vg=maxvg))
}

emma.REMLE <- function(y, X, K, Z=NULL, ngrids=100, llim=-10, ulim=10,
                       esp=1e-10, eig.L = NULL, eig.R = NULL) {
  n <- length(y)
  t <- nrow(K)
  q <- ncol(X)
  stopifnot(ncol(K) == t)
  stopifnot(nrow(X) == n)
  if ( det(crossprod(X,X)) == 0 ) {
    warning("X is singular")
    return (list(REML=0,delta=0,ve=0,vg=0))
  }
  
  if ( is.null(Z) ) {
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.wo.Z(K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1<-matrix(eig.R$values,n-q,m)
    Lambdas <- Lambdas.1 * matrix(delta,n-q,m,byrow=TRUE) + 1
    Etasq <- matrix(etas*etas,n-q,m)
    dLL <- 0.5*delta*((n-q)*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/colSums(Etasq/Lambdas)-colSums(Lambdas.1/Lambdas))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.REML.LL.wo.Z(llim,eig.R$values,etas))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.REML.LL.wo.Z(ulim,eig.R$values,etas))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.REML.dLL.wo.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas=etas)
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.REML.LL.wo.Z(r$root,eig.R$values, etas))
      }
    }
  }
  else {
    if ( is.null(eig.R) ) {
      eig.R <- emma.eigen.R.w.Z(Z,K,X)
    }
    etas <- crossprod(eig.R$vectors,y)
    etas.1 <- etas[1:(t-q)]
    etas.2 <- etas[(t-q+1):(n-q)]
    etas.2.sq <- sum(etas.2*etas.2)
    logdelta <- (0:ngrids)/ngrids*(ulim-llim)+llim
    m <- length(logdelta)
    delta <- exp(logdelta)
    Lambdas.1 <- matrix(eig.R$values,t-q,m) 
    Lambdas <- Lambdas.1 * matrix(delta,t-q,m,byrow=TRUE) + 1
    Etasq <- matrix(etas.1*etas.1,t-q,m)
    dLL <- 0.5*delta*((n-q)*colSums(Etasq*Lambdas.1/(Lambdas*Lambdas))/(colSums(Etasq/Lambdas)+etas.2.sq)-colSums(Lambdas.1/Lambdas))
    optlogdelta <- vector(length=0)
    optLL <- vector(length=0)
    if ( dLL[1] < esp ) {
      optlogdelta <- append(optlogdelta, llim)
      optLL <- append(optLL, emma.delta.REML.LL.w.Z(llim,eig.R$values,etas.1,n,t,etas.2.sq))
    }
    if ( dLL[m-1] > 0-esp ) {
      optlogdelta <- append(optlogdelta, ulim)
      optLL <- append(optLL, emma.delta.REML.LL.w.Z(ulim,eig.R$values,etas.1,n,t,etas.2.sq))
    }
    
    for( i in 1:(m-1) )
    {
      if ( ( dLL[i]*dLL[i+1] < 0-esp*esp ) && ( dLL[i] > 0 ) && ( dLL[i+1] < 0 ) ) 
      {
        r <- uniroot(emma.delta.REML.dLL.w.Z, lower=logdelta[i], upper=logdelta[i+1], lambda=eig.R$values, etas.1=etas.1, n=n, t1=t, etas.2.sq = etas.2.sq )
        optlogdelta <- append(optlogdelta, r$root)
        optLL <- append(optLL, emma.delta.REML.LL.w.Z(r$root,eig.R$values, etas.1, n, t, etas.2.sq ))
      }
    }
  }  
  maxdelta <- exp(optlogdelta[which.max(optLL)])
  optLL=replaceNaN(optLL)
  maxLL <- max(optLL)
  if ( is.null(Z) ) {
    maxve <- sum(etas*etas/(maxdelta*eig.R$values+1))/(n-q)    
  }
  else {
    maxve <- (sum(etas.1*etas.1/(maxdelta*eig.R$values+1))+etas.2.sq)/(n-q)
  }
  maxvg <- maxve*maxdelta
  return (list(REML=maxLL,delta=maxdelta,ve=maxve,vg=maxvg))
}


emma.maineffects.B<-function(Z=NULL,K,deltahat.g,complete=TRUE){
  if( is.null(Z) ){
    return(emma.maineffects.B.Zo(K,deltahat.g))
  }
  else{
    return(emma.maineffects.B.Z(Z,K,deltahat.g,complete))
  }
}


emma.maineffects.B.Zo <-function(K,deltahat.g){
  t <- nrow(K)
  stopifnot(ncol(K) == t)
  B<-deltahat.g*K+diag(1,t)
  eig<-eigen(B,symmetric=TRUE)
  qr.B<-qr(B)
  q<-qr.B$rank
  stopifnot(!is.complex(eig$values))
  A<-diag(1/sqrt(eig$values[1:q]))
  Q<-eig$vectors[,1:q]
  C<-Q%*%A%*%t(Q)
  return(list(mC=C,Q=Q,A=A))
}

emma.maineffects.B.Z <- function(Z,K,deltahat.g,complete=TRUE){
  if ( complete == FALSE ) {
    vids <- colSums(Z)>0
    Z <- Z[,vids]
    K <- K[vids,vids]
  }
  n <- nrow(Z)  
  B <- deltahat.g*Z%*%K%*%t(Z)+diag(1,n)
  eig <- eigen(B,symmetric=TRUE,EISPACK=TRUE)
  qr.B<-qr(B)
  q<-qr.B$rank
  stopifnot(!is.complex(eig$values))
  A<-diag(1/sqrt(eig$values[1:q]))
  Q<-eig$vectors[,1:q]
  C<-Q%*%A%*%t(Q)
  return(list(mC=C,Q=Q,A=A,complete=TRUE))
}
emma.MLE0.c <- function(Y_c,W_c){
  n <- length(Y_c)
  stopifnot(nrow(W_c)==n)
  M_c<-diag(1,n)-W_c%*%solve(crossprod(W_c,W_c))%*%t(W_c)
  etas<-crossprod(M_c,Y_c)
  LL <- 0.5*n*(log(n/(2*pi))-1-log(sum(etas*etas)))
  return(list(ML=LL))
}

emma.REMLE0.c <- function(Y_c,W_c){
  n <- length(Y_c)
  stopifnot(nrow(W_c)==n)
  M_c <-diag(1,n)-W_c%*%solve(crossprod(W_c,W_c))%*%t(W_c)
  eig <-eigen(M_c)
  t <-qr(W_c)$rank
  v <-n-t
  U_R <-eig$vector[,1:v]
  etas<-crossprod(U_R,Y_c)
  LL <- 0.5*v*(log(v/(2*pi))-1-log(sum(etas*etas)))
  return(list(REML=LL))
}

replaceNaN<-  function(LL) {
  index=(LL=="NaN")
  if(length(index)>0) theMin=min(LL[!index])
  if(length(index)<1) theMin="NaN"
  LL[index]=theMin
  return(LL)    
}
```

```{r}
#pLARmEB function
pLARmEB<-function(gen,phe,outATCG,genRaw,kk,psmatrix,CriLOD,lars1,Genformat,Bootstrap,CLO){

  lodvalue<-CriLOD
  gene.data<-gen
  inputform<-Genformat

  if(is.null(psmatrix)){
    flagps<-1
  }else{
    flagps<-0
  }

  if(is.null(lodvalue)==TRUE||is.null(lars1)==TRUE){
    warning("Please set parameter!")
  }
  if(lodvalue<0)
  {
    warning("Please input critical LOD score: > 0 !")
  }
  if(lars1<0||lars1>=nrow(phe))
  {
    warning("Please input the number of most relevant variables select by LARS: >0 and less than numbers of sample!")
  }
  if(is.null(gene.data)==TRUE)
  {
    warning("Please input correct genotypic data !")

  }
  if(is.null(phe)==TRUE)
  {
    warning("Please input correct phenotypic data !")
  }
  if((is.null(gene.data)==FALSE)&&(is.null(phe)==FALSE)&&(ncol(gene.data)!=(nrow(phe)+2)))
  {
    warning("Sample size in genotypic dataset doesn't equal to the sample size in phenotypic dataset !")
  }

  if((is.null(gene.data)==FALSE)&&(is.null(phe)==FALSE)&&((ncol(gene.data)==(nrow(phe)+2)))&&(lodvalue>=0)&&(lars1>0))
  {

    wan<-NULL
    result<-NULL


    lars <-  function(x, y, type = c("lasso", "lar", "forward.stagewise","stepwise"), trace = FALSE,
                      normalize=TRUE, intercept=TRUE, Gram,
                      eps = .Machine$double.eps,  max.steps, use.Gram = TRUE)
    {

      call <- match.call()
      type <- match.arg(type)
      TYPE <- switch(type,
                     lasso = "LASSO",
                     lar = "LAR",
                     forward.stagewise = "Forward Stagewise",
                     stepwise = "Forward Stepwise")
      if(trace)
        cat(paste(TYPE, "sequence\n"))

      nm <- dim(x)
      n <- nm[1]
      m <- nm[2]
      im <- inactive <- seq(m)
      one <- rep(1, n)
      vn <- dimnames(x)[[2]]
      ### Center x and y, and scale x, and save the means and sds
      if(intercept){
        meanx <- drop(one %*% x)/n
        x <- scale(x, meanx, FALSE)  # centers x
        mu <- mean(y)
        y <- drop(y - mu)
      }
      else {
        meanx <- rep(0,m)
        mu <- 0
        y <- drop(y)
      }
      if(normalize){
        normx <- sqrt(drop(one %*% (x^2)))
        nosignal<-normx/sqrt(n) < eps
        if(any(nosignal))# ignore variables with too small a variance
        {
          ignores<-im[nosignal]
          inactive<-im[-ignores]
          normx[nosignal]<-eps*sqrt(n)
          if(trace)
            cat("LARS Step 0 :\t", sum(nosignal), "Variables with Variance < eps; dropped for good\n")  #
        }
        else ignores <- NULL #singularities; augmented later as well
        names(normx) <- NULL
        x <- scale(x, FALSE, normx)	# scales x
      }
      else {
        normx <- rep(1,m)
        ignores <- NULL
      }
      if(use.Gram & missing(Gram)) {
        if(m > 500 && n < m)
          cat("There are more than 500 variables and n<m;\nYou may wish to restart and set use.Gram=FALSE\n"
          )
        if(trace)
          cat("Computing X'X .....\n")
        Gram <- t(x) %*% x	#Time saving
      }
      Cvec <- drop(t(y) %*% x)
      ssy <- sum(y^2)	### Some initializations
      residuals <- y
      if(missing(max.steps))
        max.steps <- 8*min(m, n-intercept)
      beta <- matrix(0, max.steps + 1, m)	# beta starts at 0
      lambda=double(max.steps)
      Gamrat <- NULL
      arc.length <- NULL
      R2 <- 1
      RSS <- ssy
      first.in <- integer(m)
      active <- NULL	# maintains active set
      actions <- as.list(seq(max.steps))

      drops <- FALSE
      Sign <- NULL
      R <- NULL	###

      k <- 0
      while((k < max.steps) & (length(active) < min(m - length(ignores),n-intercept)) )
      {
        action <- NULL
        C <- Cvec[inactive]	#

        Cmax <- max(abs(C))
        if(Cmax<eps*100){
          if(trace)cat("Max |corr| = 0; exiting...\n")
          break
        }
        k <- k + 1
        lambda[k]=Cmax

        if(!any(drops)) {
          new <- abs(C) >= Cmax - eps
          C <- C[!new]	# for later
          new <- inactive[new]	# Get index numbers

          for(inew in new) {
            if(use.Gram) {
              R <- updateR(Gram[inew, inew], R, drop(Gram[
                inew, active]), Gram = TRUE,eps=eps)
            }
            else {
              R <- updateR(x[, inew], R, x[, active], Gram
                           = FALSE,eps=eps)
            }
            if(attr(R, "rank") == length(active)) {

              nR <- seq(length(active))
              R <- R[nR, nR, drop = FALSE]
              attr(R, "rank") <- length(active)
              ignores <- c(ignores, inew)
              action <- c(action,  - inew)
              if(trace)
                cat("LARS Step", k, ":\t Variable", inew,
                    "\tcollinear; dropped for good\n")	#
            }
            else {
              if(first.in[inew] == 0)
                first.in[inew] <- k
              active <- c(active, inew)
              Sign <- c(Sign, sign(Cvec[inew]))
              action <- c(action, inew)
              if(trace)
                cat("LARS Step", k, ":\t Variable", inew,
                    "\tadded\n")
            }
          }
        }
        else action <-  - dropid
        Gi1 <- backsolve(R, backsolvet(R, Sign))

        dropouts<-NULL
        if(type == "forward.stagewise") {
          directions <- Gi1 * Sign
          if(!all(directions > 0)) {
            if(use.Gram) {
              nnls.object <- nnls.lars(active, Sign, R,
                                       directions, Gram[active, active], trace =
                                         trace, use.Gram = TRUE,eps=eps)
            }
            else {
              nnls.object <- nnls.lars(active, Sign, R,
                                       directions, x[, active], trace = trace,
                                       use.Gram = FALSE,eps=eps)
            }
            positive <- nnls.object$positive
            dropouts <-active[-positive]
            action <- c(action, -dropouts)
            active <- nnls.object$active
            Sign <- Sign[positive]
            Gi1 <- nnls.object$beta[positive] * Sign
            R <- nnls.object$R
            C <- Cvec[ - c(active, ignores)]
          }
        }
        A <- 1/sqrt(sum(Gi1 * Sign))
        w <- A * Gi1	# note that w has the right signs
        if(!use.Gram) u <- drop(x[, active, drop = FALSE] %*% w)	###

        if( (length(active) >=  min(n-intercept, m - length(ignores) ) )|type=="stepwise") {
          gamhat <- Cmax/A
        }
        else {
          if(use.Gram) {
            a <- drop(w %*% Gram[active,  - c(active,ignores), drop = FALSE])
          }
          else {
            a <- drop(u %*% x[,  - c(active, ignores), drop=FALSE])
          }
          gam <- c((Cmax - C)/(A - a), (Cmax + C)/(A + a))

          gamhat <- min(gam[gam > eps], Cmax/A)
        }
        if(type == "lasso") {
          dropid <- NULL
          b1 <- beta[k, active]	# beta starts at 0
          z1 <-  - b1/w
          zmin <- min(z1[z1 > eps], gamhat)
          if(zmin < gamhat) {
            gamhat <- zmin
            drops <- z1 == zmin
          }
          else drops <- FALSE
        }
        beta[k + 1,  ] <- beta[k,  ]
        beta[k + 1, active] <- beta[k + 1, active] + gamhat * w
        if(use.Gram) {
          Cvec <- Cvec - gamhat * Gram[, active, drop = FALSE] %*% w
        }
        else {
          residuals <- residuals - gamhat * u
          Cvec <- drop(t(residuals) %*% x)
        }
        Gamrat <- c(Gamrat, gamhat/(Cmax/A))
        arc.length <- c(arc.length, gamhat)
        if(type == "lasso" && any(drops)) {
          dropid <- seq(drops)[drops]
          for(id in rev(dropid)) {
            if(trace)
              cat("Lasso Step", k+1, ":\t Variable", active[
                id], "\tdropped\n")
            R <- downdateR(R, id)
          }
          dropid <- active[drops]
          beta[k+1,dropid]<-0
          active <- active[!drops]
          Sign <- Sign[!drops]
        }
        if(!is.null(vn))
          names(action) <- vn[abs(action)]
        actions[[k]] <- action
        inactive <- im[ - c(active, ignores)]
        if(type=="stepwise")Sign=Sign*0
      }
      beta <- beta[seq(k + 1), ,drop=FALSE ]
      lambda=lambda[seq(k)]
      dimnames(beta) <- list(paste(0:k), vn)
      if(trace)
        cat("Computing residuals, RSS etc .....\n")
      residuals <- y - x %*% t(beta)
      beta <- scale(beta, FALSE, normx)
      RSS <- apply(residuals^2, 2, sum)
      R2 <- 1 - RSS/RSS[1]
      actions=actions[seq(k)]
      netdf=sapply(actions,function(x)sum(sign(x)))
      df=cumsum(netdf)### This takes into account drops
      if(intercept)df=c(Intercept=1,df+1)
      else df=c(Null=0,df)
      rss.big=rev(RSS)[1]
      df.big=n-rev(df)[1]
      if(rss.big<eps|df.big<eps)sigma2=NaN
      else
        sigma2=rss.big/df.big
      Cp <- RSS/sigma2 - n + 2 * df
      attr(Cp,"sigma2")=sigma2
      attr(Cp,"n")=n
      object <- list(call = call, type = TYPE, df=df, lambda=lambda,R2 = R2, RSS = RSS, Cp = Cp,
                     actions = actions[seq(k)], entry = first.in, Gamrat = Gamrat,
                     arc.length = arc.length, Gram = if(use.Gram) Gram else NULL,
                     beta = beta, mu = mu, normx = normx, meanx = meanx)
      class(object) <- "lars"
      object
    }

    Y.data<-as.matrix(phe)
    if(is.null(psmatrix)==FALSE){
      psmatrix<-as.matrix(psmatrix)
    }
    nsam <-ncol(gene.data)-2
    chrnum<-length(unique(gene.data[,1]))

    W.orig<-matrix(1,nsam,1)
    if(is.null(psmatrix)==FALSE){
      W1 <-cbind(W.orig,psmatrix)
    }else{
      W1<-W.orig
    }

    cl.cores <- detectCores()
    if((cl.cores<=2)||(is.null(CLO)==FALSE)){
      cl.cores<-1
    }else if(cl.cores>2){
      if(cl.cores>10){
        cl.cores<-10
      }else {
        cl.cores <- detectCores()-1
      }
    }

    cl <- makeCluster(cl.cores)
    registerDoParallel(cl)


    larsres<-foreach(i=1:chrnum,.multicombine=TRUE,.combine='rbind')%dopar%{

      requireNamespace("foreach")
      requireNamespace("lars")
      requireNamespace("sampling")

      xxot <- as.matrix(gene.data[(gene.data[,1])!=i,3:ncol(gene.data)])
      xot <-t(xxot)
      nmarkot <-ncol(xot)
      kk<-matrix(0,nsam,nsam)
      for(k in 1:nmarkot)
      {
        z<-as.matrix(xot[,k])
        kk<-kk+z%*%t(z)
      }

      cc<-mean(diag(kk))
      K1 <- numeric()
      K1 <- kk/cc

      xx1 <- as.matrix(gene.data[gene.data[,1]==i,3:ncol(gene.data)])
      YY1 <- matrix(Y.data,,1)

      repl<-numeric()
      if(Bootstrap==TRUE){

        res1<-foreach(repl=1:5,.multicombine=TRUE,.combine='cbind')%do%{

          if(repl==1){
            YY<-YY1
            xx<-xx1
            K<-K1
            W<-W1
          }else{
            s<-srswr(nrow(YY1),nrow(YY1))
            ind<-(1:nrow(YY1))[s!=0]
            n<-s[s!=0]
            ind<-rep(ind,times=n)
            YY<-as.matrix(YY1[ind,])
            xx<-xx1[,ind]

            xxot2<-xxot[,ind]
            xot2 <-t(xxot2)
            nmarkot2 <-ncol(xot2)
            kk2<-matrix(0,nsam,nsam)
            for(k in 1:nmarkot2)
            {
              z2<-as.matrix(xot2[,k])
              kk2<-kk2+z2%*%t(z2)
            }
            cc2<-mean(diag(kk2))
            K <- numeric()
            K <- kk2/cc2
            W<-as.matrix(W1[ind,])
          }

          remle2<-emma.REMLE(YY, W, K, Z=NULL, ngrids=100, llim=-10, ulim=10,esp=1e-10, eig.L = NULL, eig.R = NULL)
          remle1.B1<-emma.maineffects.B(Z=NULL,K,remle2$delta)
          C2<-remle1.B1$mC
          Y_c <- C2%*%YY
          W_c <- C2%*%W
          G_c <- C2%*%t(xx)
          GGG <- t(G_c)
          ylars <- as.matrix(Y_c)
          xlars <- cbind(W_c,t(GGG))
          LAR <- lars(xlars,ylars,type="lar",use.Gram=F,max.steps=lars1)
          LAR$beta[nrow(LAR$beta),]
        }

      }else if(Bootstrap==FALSE){
        YY<-YY1
        xx<-xx1
        K<-K1
        W<-W1
        res1 <- numeric()
        remle2<-emma.REMLE(YY, W, K, Z=NULL, ngrids=100, llim=-10, ulim=10,esp=1e-10, eig.L = NULL, eig.R = NULL)
        remle1.B1<-emma.maineffects.B(Z=NULL,K,remle2$delta)
        C2<-remle1.B1$mC
        Y_c <- C2%*%YY
        W_c <- C2%*%W
        G_c <- C2%*%t(xx)
        GGG <- t(G_c)
        ylars <- as.matrix(Y_c)
        xlars <- cbind(W_c,t(GGG))
        LAR <- lars(xlars,ylars,type="lar",use.Gram=F,max.steps=lars1)
        res1<-cbind(res1,LAR$beta[nrow(LAR$beta),])
      }

      if(is.null(psmatrix)==FALSE){
        rr <- as.matrix(res1[-c(1:(ncol(psmatrix)+1)),])
      }else{
        rr <- as.matrix(res1[-1,])
      }
    }

    stopCluster(cl)

    if(Bootstrap==TRUE){
      count <- matrix(rep(0,nrow(larsres)),nrow(larsres),1)

      ttt <- numeric()
      for(ii in 1:nrow(larsres))
      {
        tt <- 0
        for(jj in 1:ncol(larsres))
        {
          if ((abs(larsres[ii,jj]))>0){tt <- tt+1}
        }
        count[ii] <-tt
      }
      larsres <-cbind(larsres,count)

      for(ii in 1:nrow(larsres))
      {
        if(larsres[ii,ncol(larsres)]>=3){ttt <- cbind(ttt,ii)}
      }

      countnum <- ttt

    }else{

      countnum <- numeric()
      for(ii in 1:nrow(larsres))
      {
        if ((abs(larsres[ii]))>0){countnum <- cbind(countnum,ii)}
      }
    }


    if(ncol(countnum)>nrow(phe)){

      if(length(countnum)==1){
        xx2 <- matrix(gene.data[countnum,3:ncol(gene.data)],1,)

      }else{
        xx2 <- as.matrix(gene.data[countnum,3:ncol(gene.data)])
      }
      YY2 <- matrix(Y.data,,1)

      ylars <- as.matrix(YY2)
      xlars <- cbind(W1,t(xx2))
      LAR <- lars(xlars,ylars,type="lar",use.Gram=F)

      res1<-as.matrix(LAR$beta[nrow(LAR$beta),])

      if(is.null(psmatrix)==FALSE){
        rr <- as.matrix(res1[-c(1:(ncol(psmatrix)+1)),])
      }else{
        rr <- as.matrix(res1[-1,])
      }

      ct <- numeric()
      for(ii in 1:nrow(rr))
      {
        if ((abs(rr[ii]))>0){ct <- cbind(ct,ii)}
      }

      inct<-c(ct)
      countnum<-countnum[,inct]

    }

    if(length(countnum)==1){
      xeb <- matrix(gene.data[countnum,],1,)
      ebrow <-matrix(xeb[,1:2],,2)
      xeb1<-matrix(xeb[,3:ncol(xeb)],1,)
      xxeb <- as.matrix(t(xeb1))
      nmak <- ncol(xxeb)

    }else{
      xeb <- as.matrix(gene.data[countnum,])
      ebrow <-as.matrix(xeb[,1:2])
      xeb1<-as.matrix(xeb[,3:ncol(xeb)])
      xxeb <- as.matrix(t(xeb1))
      nmak <- ncol(xxeb)
    }
    bayeslodres <- numeric()

    yeb <- as.matrix(phe)

    if(is.null(psmatrix)==FALSE){
      u1<-ebayes_EM(cbind(matrix(1,nrow(xxeb),1),psmatrix),xxeb,yeb)
      xb<-u1$u
    }else{
      u1<-ebayes_EM(matrix(1,nrow(xxeb),1),xxeb,yeb)
      xb<-u1$u
    }
    xb<-as.matrix(xb)
    if(is.null(psmatrix)==FALSE){
      temp<-cbind(matrix(1,nrow(xxeb),1),psmatrix)
    }else{
      temp<-matrix(1,nrow(xxeb),1)
    }

    lodres<-likelihood(temp,xxeb,yeb,xb)
    lodres<-as.matrix(lodres)
    #### compute heredity#######
    ch_er <- as.numeric()
    ch_x <- cbind(matrix(1,nrow(xxeb),1),xxeb)

    ch_bb <- rbind(mean(yeb),as.matrix(xb))


    for(i in 1:(ncol(ch_x)-1))
    {
      ch_xi <- ch_x[,(1+i)]
      as1 <- length(which(ch_xi==1))/nrow(ch_x)
      as2 <- 1-as1
      ch_er <- rbind(ch_er,(1-(as1-as2)*(as1-as2))*ch_bb[i+1]*ch_bb[i+1])
    }
    ch_v0 <- (1/(nrow(ch_x)-1))*(t(yeb-ch_x%*%ch_bb)%*%(yeb-ch_x%*%ch_bb))

    if(var(yeb)>=sum(ch_er)+ch_v0){
      hered <- (ch_er/as.vector(var(yeb)))*100
    }else{
      hered <- (ch_er/as.numeric(sum(ch_er)+ch_v0))*100
    }

    bayeslodres<-cbind(ebrow,xb,lodres,hered)


    lodid<-which(bayeslodres[,4]>lodvalue)
    if(length(lodid)!=0){

      if(length(lodid)==1){
        lastres<-matrix(bayeslodres[lodid,],1,)
        xeb2<-matrix(xeb1[lodid,],1,)
      }else{
        lastres<-bayeslodres[lodid,]
        xeb2<-as.matrix(xeb1[lodid,])
      }

      xxmaf<- xeb2
      leng.maf<-dim(xxmaf)[2]

      maf.fun<-function(snp){
        leng<-length(snp)
        snp1<-length(which(snp==1))
        snp11<-length(which(snp==-1))
        snp0<-length(which(snp==0))
        ma1<-(2*snp1+snp0)/(2*leng)
        ma2<-(2*snp11+snp0)/(2*leng)
        maf<-min(ma1,ma2)
        return(maf)
      }

      maf<-apply(xxmaf,1,maf.fun)
      maf<-as.matrix(round(maf,4))
      vee<-round(u1$sigma2,4)
      pee<-round(var(yeb),4)

      vees<-matrix("",nrow = nrow(lastres),1)
      pees<-matrix("",nrow = nrow(lastres),1)
      pees[1,1]<-pee
      vees[1,1]<-vee
      result<-lastres
      result<-result

      if(nrow(result)>1){
        temp<-as.matrix(result[,3:5])
        temp[which(abs(temp)>=1e-4)]<-round(temp[abs(temp)>=1e-4],4)
        temp[which(abs(temp)<1e-4)]<-as.numeric(sprintf("%.4e",temp[abs(temp)<1e-4]))
        wan<-cbind(result[,1:2],temp)
      }else{
        temp<-t(as.matrix(result[,3:5]))
        temp[which(abs(temp)>=1e-4)]<-round(temp[abs(temp)>=1e-4],4)
        temp[which(abs(temp)<1e-4)]<-as.numeric(sprintf("%.4e",temp[abs(temp)<1e-4]))
        wan<-cbind(t(as.matrix(result[,1:2])),temp)
      }

      if(inputform==1){
        genRaw<-as.data.frame(genRaw)
        genraw<-genRaw[-1,1:4]

        wan_len<-dim(wan)[1]
        marker<-character()
        snp<-character()

        for(i in 1:wan_len){
          chr_pos<-which(genraw[,2]==wan[i,1])
          new_matrix<-genraw[chr_pos,]
          posi_pos<-which(new_matrix[,3]==wan[i,2])
          mark<-matrix(new_matrix[posi_pos,1],1,)
          marker<-rbind(marker,mark)
          sn<-matrix(new_matrix[posi_pos,4],1,)
          snp<-rbind(snp,sn)
        }
      }
      if(inputform==2){

        genRaw<-as.data.frame(genRaw)
        genraw<-genRaw[-1,1:4]

        wan_len<-dim(wan)[1]
        marker<-character()
        snp<-character()
        for(i in 1:wan_len){
          chr_pos<-which(genraw[,2]==wan[i,1])
          new_matrix<-genraw[chr_pos,]
          posi_pos<-which(new_matrix[,3]==wan[i,2])
          mark<-matrix(new_matrix[posi_pos,1],1,)
          marker<-rbind(marker,mark)
          sn<-matrix(new_matrix[posi_pos,4],1,)
          snp<-rbind(snp,sn)
        }
      }
      if(inputform==3){
        genRaw<-as.data.frame(genRaw)
        genraw<-genRaw[-1,c(1,3,4,12)]

        wan_len<-dim(wan)[1]
        marker<-character()
        snp<-character()
        for(i in 1:wan_len){
          chr_pos<-which(genraw[,2]==wan[i,1])
          new_matrix<-genraw[chr_pos,]
          posi_pos<-which(new_matrix[,3]==wan[i,2])
          mark<-matrix(new_matrix[posi_pos,1],1,)
          marker<-rbind(marker,mark)
          sn<-matrix(new_matrix[posi_pos,4],1,)
          snp<-rbind(snp,sn)
        }
      }

      wan<-cbind(marker,wan,maf,snp,vees,pees)
      tempwan <- wan
      lodscore1 <- as.numeric(tempwan[,5])
      log10P <- as.matrix(round(-log10(1-pchisq(lodscore1*4.605,1)),4))
      if(nrow(tempwan)>1){
        tempwan1 <- cbind(tempwan[,1:5],log10P,tempwan[,6:10])
      }else{
        tempwan1 <- cbind(t(as.matrix(tempwan[,1:5])),log10P,t(as.matrix(tempwan[,6:10])))
      }
      wan <- tempwan1
      colnames(wan)<-c("RS#","Chromosome","Marker Position (bp)","QTN effect","LOD score","-log10(P)","r2 (%)","MAF","Genotype  for code 1","Var_Error","Var_phen (total)")
      wan<-as.data.frame(wan)

      result<-as.data.frame(result)
    }

    if(nrow(result)>1){
      r1<-as.matrix(result[,c(1,2,4)])
    }else{
      r1<-t(as.matrix(result[,c(1,2,4)]))
    }
    r2<-as.matrix(gen[,1:2])
    rowbl<-nrow(r2)-nrow(r1)
    bl<-matrix("",rowbl,3)
    r12<-rbind(r1,bl)
    result<-cbind(r2,r12)

    colnames(result)<-c("Chromosome","Marker Position (bp)","Chromosome(detected)","Marker Position (bp)(detected)","LOD score(detected)")

    output<-list(result=wan,plot=result)
  }

  return(output)

}
```

```{r}
#Run pLARmEB
pheno_col <- as.data.frame(pheno$X3_SD)
y_uncut <- pheno_col
y<-as.data.frame(y_uncut[as.vector(!is.na(y_uncut)),])
ps<- ps_uncut[as.vector(!is.na(y_uncut)),]
fin_geno <- cbind(genRaw[2:dim(genRaw)[1],1:2], num_geno[,as.vector(!is.na(y_uncut))])
geno_mat <- data.matrix(fin_geno)
plar_out <- pLARmEB(geno_mat, y, outATCG=NULL, genRaw, gkin, ps, 3.3, 10, 1, Bootstrap=FALSE, 2)
```


```{r}
# Set up data for HA-Coef
map <- geno@map
chrom <- geno@chromosome
snp_names <- geno@snpnames
per_chrom_map <- lapply(map, per_chrom) 
```

```{r}
# Run HA-Coef
sum_vec <- 0
ptm1 <- proc.time()
convert <- function(x) as.numeric(factor(x, levels = names(sort(-table(x)))))

dat <- fread("Arabidopsis_geno.txt", sep=",")
dat <- as.data.frame(lapply(dat, FUN = convert))
res <- 0
pheno <- fread("Arabidopsis_pheno.txt", sep=",")[["X57_FT_Field"]] #dat[,length(dat[1,])]
for (i in 2:(length(dat[1,]))){
su <- 0
geno <- dat[,i]
dim(geno)
ave_0 <- mean( pheno[geno == 1], na.rm=TRUE) #changed to 1 from 0
ave_1 <- mean( pheno[geno == 2], na.rm=TRUE) #changed to 2 from 1
ord <- c(ave_0, ave_1)
ord <- rank(ord)
ref <- c(0,1)
who_len <- length(geno)
min_len <- length( which( geno == ref[ which(ord == 1) ]) )
max_len <- length( which( geno == ref[ which(ord == 2) ]) )
i_list <- sort(pheno,decreasing=F)
top_g0 <- i_list[1 : min_len]
top_g1 <- i_list[(min_len + 1) : (min_len + max_len) ]
r_list <- sort( pheno,decreasing=T)
bot_g0 <- r_list[1 : min_len]
bot_g1 <- r_list[(min_len + 1) : (min_len + max_len) ]
top_s0 <- sum(top_g0, na.rm=TRUE)
top_s1 <- sum(top_g1, na.rm=TRUE)
bot_s0 <- sum(bot_g0, na.rm=TRUE)
bot_s1 <- sum(bot_g1, na.rm=TRUE)
obs_s0 <- sum( pheno[which( geno == ref[ which(ord == 1) ])], na.rm=TRUE)
obs_s1 <- sum( pheno[which( geno == ref[ which(ord == 2) ])], na.rm=TRUE)
su <- obs_s0 + obs_s1
x2 <- (su*log(obs_s1) - obs_s1) - (su*log(bot_s1) - bot_s1)
x1 <- (su*log(top_s1) - top_s1) - (su*log(bot_s1) - bot_s1)
res_1 <- x2/x1
if(is.na(res_1) | res_1 < 0 | res_1 == Inf){
  res[i-1] <- 0
}
else {
  res[i-1] <- res_1
}
}

sum_vec <- sum_vec + res

ptm2 <- proc.time()
cat(ptm2-ptm1)

plot(map, res, col=chrom, xlab="Map Position", ylab="HA-coefficient", main="HA Coefficient GWAS of Phenotype FT_Field")

```

